/// These are automatically generated C++ bindings for isl.
///
/// isl is a library for computing with integer sets and maps described by
/// Presburger formulas. On top of this, isl provides various tools for
/// polyhedral compilation, ranging from dependence analysis over scheduling
/// to AST generation.

#ifndef ISL_CPP_NOEXCEPTIONS
#define ISL_CPP_NOEXCEPTIONS

#include <isl/aff.h>
#include <isl/ast_build.h>
#include <isl/flow.h>
#include <isl/ilp.h>
#include <isl/map.h>
#include <isl/schedule.h>
#include <isl/schedule_node.h>
#include <isl/set.h>
#include <isl/union_map.h>
#include <isl/union_set.h>
#include <isl/val.h>

#include <functional>
#include <string>

namespace isl {
inline namespace noexceptions {

#define ISLPP_STRINGIZE_(X) #X
#define ISLPP_STRINGIZE(X) ISLPP_STRINGIZE_(X)

#define ISLPP_ASSERT(test, message)                          \
  do {                                                       \
    if (test)                                                \
      break;                                                 \
    fputs("Assertion \"" #test "\" failed at " __FILE__      \
      ":" ISLPP_STRINGIZE(__LINE__) "\n  " message "\n",     \
      stderr);                                               \
  } while (0)

class boolean {
private:
  isl_bool val;

  friend isl::boolean manage(isl_bool val);
  boolean(isl_bool val): val(val) {}
public:
  boolean()
      : val(isl_bool_error) {}

  /* implicit */ boolean(bool val)
      : val(val ? isl_bool_true : isl_bool_false) {}

  bool is_error() const { return val == isl_bool_error; }
  bool is_false() const { return val == isl_bool_false; }
  bool is_true() const { return val == isl_bool_true; }

  explicit operator bool() const {
    ISLPP_ASSERT(!is_error(), "IMPLEMENTATION ERROR: Unhandled error state");
    return is_true();
  }

  boolean operator!() const {
    if (is_error())
      return *this;
    return !is_true();
  }
};

inline isl::boolean manage(isl_bool val) {
  return isl::boolean(val);
}

class ctx {
  isl_ctx *ptr;
public:
  /* implicit */ ctx(isl_ctx *ctx)
      : ptr(ctx) {}
  isl_ctx *release() {
    auto tmp = ptr;
    ptr = nullptr;
    return tmp;
  }
  isl_ctx *get() {
    return ptr;
  }
};

enum class stat {
  ok = isl_stat_ok,
  error = isl_stat_error
};

template <typename T>
class list;

template <typename T>
class list_iterator {
  const list<T> *lst;
  int pos;
  mutable T elementHolder;

  inline list_iterator(const list<T> *l, int p);

  friend list_iterator list<T>::begin() const;
  friend list_iterator list<T>::end() const;

public:
  typedef T value_type;
  typedef int difference_type;
  typedef std::input_iterator_tag iterator_category;
  typedef const T *pointer;
  typedef T reference;

  inline list_iterator();
  inline list_iterator(const list_iterator<T> &it);
  inline ~list_iterator();
  inline list_iterator &operator=(const list_iterator<T> &it);

  inline reference operator*() const;
  inline pointer operator->() const;
  inline list_iterator operator++(int);
  inline list_iterator &operator++();
  inline bool operator==(const list_iterator<T> &it) const;
  inline bool operator!=(const list_iterator<T> &it) const;

  static inline void swap(list_iterator<T> &it1, list_iterator<T> &it2);
};

template <typename T>
list_iterator<T>::list_iterator(const list<T> *l, int p) :
  lst(l), pos(p) {}

template <typename T>
list_iterator<T>::list_iterator() :
  lst(nullptr), pos(-1) {}

template <typename T>
list_iterator<T>::list_iterator(const list_iterator<T> &it) :
  lst(it.lst), pos(it.pos) {}

template <typename T>
list_iterator<T> &list_iterator<T>::operator=(const list_iterator<T> &it) {
  lst = it.lst;
  pos = it.pos;
  return *this;
}

template <typename T>
list_iterator<T>::~list_iterator() {}

template <typename T>
typename list_iterator<T>::reference list_iterator<T>::operator*() const {
  return lst->at(pos);
}

template <typename T>
typename list_iterator<T>::pointer list_iterator<T>::operator->() const {
  elementHolder = lst->at(pos);
  return &elementHolder;
}

template <typename T>
list_iterator<T> list_iterator<T>::operator++(int) {
  list_iterator<T> it = *this;
  ++*this;
  return it;
}

template <typename T>
list_iterator<T> &list_iterator<T>::operator++() {
  if (pos == -1 || !lst || pos >= lst->size() - 1)
    pos = -1;
  else
    ++pos;

  return *this;
}

template <typename T>
bool list_iterator<T>::operator==(const list_iterator<T> &it) const {
  ISLPP_ASSERT(lst == it.lst,
               "cannot compare iterators from different containers");
  return pos == it.pos;
}

template <typename T>
bool list_iterator<T>::operator!=(const list_iterator<T> &it) const {
  return !(*this == it);
}

}
} // namespace isl
